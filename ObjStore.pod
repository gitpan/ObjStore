=head1 NAME

ObjStore - perl extension for ObjectStore OODBMS

=head1 SYNOPSIS

  use ObjStore ':ALL';

  my $db = ObjStore::open(&schema_dir . "/perltest.db", 0, 0666);

  try_update {
      my $top = $db->root('whiteboard') ||
                $db->root('whiteboard', new ObjStore::AV($db, 1000));
      for (my $x=1; $x < 10000; $x++) {
          my $z= $top->[$x];
          $top->[$x] ||= {
               id => $x,
               m1 => "I will not talk in ObjectStore/perl class.",
               m2 => "I will study the documentation before asking questions.",
          };
      }
      print "Very impressive.  I see you are already an expert.\n";
  };

=head1 DESCRIPTION

The new SQL and the sunset of relational databases.

ObjectStore is the leading object-oriented database.  It is engineered
by Object Design, Inc. (http://www.odi.com) (NASDAQ: ODIS).  The
database uses the virtual memory mechanism to make persistent data
available in the most efficient manner possible.

In case you didn't know, Object Design's Persistent Storage Engine has
been licensed by Sun, Microsoft, Netscape, and Symantic for inclusion in
their Java development environments.

Prior to this joining of forces,

=over 4

=item *

ObjectStore was too radical a design decision for many applications.

=item *

perl5 did not have a simple way of storing complex data persistently.

=back

I<Now there is an easy way to build databases, especially if you care about
preserving your ideals of data encapsulation.  (See below!)>

=head1 API

Much of the perl API is a direct interface to the C++ API.  Refer to
the ObjectStore documentation for exact symantics.  If you need a
function that isn't available in perl, send mail to the OS/perl
mailing list (see the README).

Fortunately, you probably wont need to use most of the API.  It is
listed below simply to make you feel more comfortable.

=head2 ObjStore

=over 4

=item * $name = ObjStore::release_name()

=item * $major = ObjStore::release_major()

=item * $minor = ObjStore::release_minor()

=item * $maintenance = ObjStore::release_maintenance()

=item * $yes = ObjStore::network_servers_available();

=item * ObjStore::set_auto_open_mode(mode, fp, [sz]);

=item * $num = ObjStore::return_all_pages();

=item * $size = ObjStore::get_page_size();

=item * @Servers = ObjStore::get_all_servers();

=item * $in_abort = ObjStore::abort_in_progress();

=item * $db = ObjStore::open($pathname, $read_only, $mode);

=item * $num = ObjStore::get_n_databases();

=back

=head2 ::Server

=over 4

=item * $name = $s->get_host_name();

=item * $is_broken = $s->connection_is_broken();

=item * $s->disconnect();

=item * $s->reconnect();

=item * @Databases = $s->get_databases();

=back

=head2 ::Database

=over 4

=item * $db->close();

=item * $db->destroy();

=item * $db->get_default_segment_size();

=item * $db->get_sector_size();

=item * $db->size();

=item * $db->size_in_sectors();

=item * $ctime = $db->time_created();

=item * $is_open = $db->is_open();

=item * $db->open_mvcc();

=item * $is_mvcc = $db->is_open_mvcc();

=item * $read_only = $db->is_open_read_only();

=item * $can_write = $db->is_writable();

=item * $db->set_fetch_policy(policy[, blocksize]);

Policy can be one of C<segment>, C<page>, or C<stream>.

=item * $db->set_lock_whole_segment(policy);

Policy can be one of C<as_used>, C<read>, or C<write>.

=item * $db = ObjStore::Database::of($pvar);

=item * $Seg = $db->create_segment();

=item * $Seg = $db->get_segment($segment_number);

=item * @Segments = $db->get_all_segments();

=item * @Roots = $db->get_all_roots();

=item * $root = $db->create_root($root_name);

=item * $root = $db->find_root($root_name);

=item * $value = $db->root($root_name[, $new_value]);

This is the recommended API for roots.  If the given root is not
found, creates a new one.  Sets the root's value if $new_value is
defined.  Returns the root's current value.

=item * $db->destroy_root($root_name);

Destroys the root with the given name if it exists.

=back

=head2 ::Root

=over 4

=item * $root->get_name();

=item * $root->get_value();

=item * $root->set_value($new_value);

=item * $root->destroy();

=back

=head2 ::Transaction

ObjectStore transactions and exceptions are seemlessly integrated into
perl.  ObjectStore exceptions cause a C<die> in perl just as perl
exceptions cause a transaction abort.

    try_update {
        $top = $db->root('top');
        $top->{abc} = 3;
        die "Oops!  abc should not change!";       # aborts the transaction
    };

There are three types of transactions: C<try_read>, C<try_update>,
and C<try_abort_only>.  In a read transaction, you are not allowed
to modify persistent data.

    try_read {
	my $var = $db->root('top');
	$var->{abc} = 7;	# write to $var triggers die(...)
    };

=over 4

=item * $T = ObjStore::Transaction::get_current();

=item * $type = $T->get_type();

=item * $pop = $T->get_parent();

=item * $T->prepare_to_commit();

=item * $yes = $T->is_prepare_to_commit_invoked();

=item * $yes = $T->is_prepare_to_commit_completed();

=item * ObjStore::set_transaction_priority($very_low);

=item * ObjStore::set_max_retries($oops);

=item * ObjStore::rethrow_exceptions

=item * my $oops = ObjStore::get_max_retries();

=item * my $yes = ObjStore::is_lock_contention();

=item * my $type = ObjStore::get_lock_status($ref);

=item * my $tm = ObjStore::get_readlock_timeout();

=item * my $tm = ObjStore::get_writelock_timeout();

=item * ObjStore::set_readlock_timeout($tm);

=item * ObjStore::set_writelock_timeout($tm);

=back

=head2 ::Segment

=over 4

=item * $Seg->destroy();

=item * $size = $Seg->size();

=item * $yes = $Seg->is_empty();

=item * $yes = $Seg->is_deleted();

=item * $num = $Seg->get_number();

=item * $comment = $Seg->get_comment();

=item * $Seg->set_comment($comment);

=item * $Seg->lock_into_cache();

=item * $Seg->unlock_from_cache();

=item * $Seg->set_fetch_policy($policy[, $size]);

Policy can be one of C<segment>, C<page>, or C<stream>.

=item * $Seg->set_lock_whole_segment($policy);

Policy can be one of C<as_used>, C<read>, or C<write>.

=item * $Seg = ObjStore::Segment::of($pvar);

=back

=head1 CREATING CONTAINERS

Databases are comprised of segments.  Segments dynamically resize from
very small to very big.  You should split your data into lots segments
when it makes sense.  Segment improve locality of reference and can be
a unit of locking or caching.

When you create a container you must specify the segment in which it
is to be allocated.  All containers are created using the form C<'new
ObjStore::$type($store, $cardinality)'>.  You may pass any persistent
object in place of $store and the new container will be created in the
same segment as the $store object!

=head2 Arrays

The following code snippet creates a persistent array reference with
an expected cardinality of ten elements.

    my $a7 = new ObjStore::AV($store, 10);

None of the usually array operations are supported except fetch and
store.  At least the following works:

    $a7->[1] = [1,2,3,[4,5],6];

Complete array support will be available as soon as Larry and friends
fix the TIEARRAY interface.  (See perltie(3) or http://www.perl.com
more info.)

=head2 Hashes

The following code snippet creates a persistent hash reference with an
expected cardinality of ten elements.

    my $h7 = new ObjStore::HV($store, 10);

An array representation is used for low cardinalities.  Arrays do not
scale well, but they do afford a compact representation.
ObjectStore's C<os_Dictionary> is used for large cardinalities.

Data structures can be built with the normal perl syntax:

    $h7->{foo} = { 'fwaz'=> { 1=>'blort', 'snorf'=>3 }, b=>'ouph' };

Or the equally effective but unbearibly tedious:

    my $h1 = $dict->{foo} ||= new ObjStore::HV($dict);
    my $h2 = $h1->{fwaz} ||= new ObjStore::HV($h1);
    $h2->{1}='blort';
    $h2->{snorf}=3;
    $h1->{b}='ouph';

Perl saves us again!  Relief.

=head2 Sets

The following code snippet creates a set with an expected cardinality
of ten elements.

    my $set = new ObjStore::Set($store, 10);

Sets are simple collections.  They do not support duplicates.  The
following methods are supported:

    $set->add($obj, { hello=>1 });
    $set->rm($obj);
    $yes = $set->contains($obj);
    for (my $obj = $set->first; $obj; $obj = $set->next) {
	# do something with $obj
    }

An array representation is used for low cardinalities.  Arrays are not
efficient, but they are compact.  ObjectStore's C<os_set> is
used for large cardinalities.

Changing the membership of a set while iterating over the members
has undefined results.

=head1 OSPEEK

While there is no official schema for a perl database, the C<ospeek>
utility generates a sample of data content and structure.  The
following output was snapped from a database that supports a CGI
application we have developed.  Note how circular references and
pointers between objects are summarized.

=head2 Wait!  No Schema?!  How Can This Scale?

How can relational databases scale?!  When you write down a central
schema, you are violating the principle of encapsulation.  This is
dumb.  None of the usual database operations require a central schema.
Why create artificial dependencies between your classes when you can
avoid it?

=head2 Lazy Evolution

Even schema evolution can be done piecemeal.  Give all your objects an
C<evolve> method that insures that the representation is up-to-date.

=over 4

=item *

Either tag your objects with version numbers,

=item *

Or intelligently figure out how to evolve objects by examining their
current structure.

=back

The main thing is to keep an archive of prior formats of object
instances to regression test your new C<evolve> methods.  If you can
do extracts to a mini-database, that would do the trick.  Then just
run your new code through a historical mini-database.

=head2 ospeek Example Output

 ObjStore::Root Bright = Node {
    VERSION => 5,
    center => 1,
    ctime => '19970814113317',
    daily_hits => ObjStore::HV {
      19970814 => 1,
    },
    desc => 'We are what we think.  All that we are arises with our thoughts.  With our thoughts we make the world.',
    hits => 1,
    name => 'Bright',
    owner => '0',
    reflected => '0',
    rel => ObjStore::Set [
      Node {
        ctime => '19970814113317',
        daily_hits => ObjStore::HV {
          19970814 => 8,
        },
        desc => '',
        hits => 8,
        n_anon => 6,
        name => 'Joe's Store',
        owner => Node { ... }
        reflected => 1,
        rel => ObjStore::Set [
          Node { ... }
          Node {
            ctime => '19970814113317',
            desc => 'New users arrive here.',
            hits => '0',
            index => ObjStore::HV {
              Anon-4 => User {
                ctime => '19970814130657',
                daily_hits => ObjStore::HV {
                  19970814 => 1,
                },
                desc => 'Anonymous temporary login.',
                expire => '19970915130657',
                hits => 1,
                name => 'Anon-4',
                owner => User { ... }
                reflected => 3,
                rel => ObjStore::Set [
                  Node { ... }
                ],
                views => ObjStore::HV {
                  1 => User::View {
                    at => Node {
                      color => 'light green',
                      ctime => '19970814124048',
                      daily_hits => ObjStore::HV {
                        19970814 => 8,
                      },
                      desc => '',
                      hits => 8,
                      name => 'Research',
                      owner => Node { ... }
                      reflected => 1,
                      rel => ObjStore::Set [
                        Node { ... }
                        Node { ... }
                        Node { ... }
                        Node { ... }
                      ],
                      url => '',
                    },
                    prior => ObjStore::HV {
                      0 => Node { ... }
                      1 => Node { ... }
                      2 => User { ... }
                    },
                  },
                  2 => User::View {
                    at => User { ... }
                  },
                },
              },
              Anon-5 => User {
                ctime => '19970814191636',
                desc => 'Anonymous temporary login.',
                expire => '19971013191636',
                hits => '0',
                name => 'Anon-5',
                owner => User { ... }
                reflected => 3,
                rel => ObjStore::Set [
                  Node { ... }
                ],
                views => ObjStore::HV {
                  1 => User::View {
                    at => User { ... }
                    prior => ObjStore::HV {
                      0 => User { ... }
                    },
                  },
                  2 => User::View {
                    at => User { ... }
                  },
                },
              },
              Anon-6 => User {
                ctime => '19970814191724',
                desc => 'Anonymous temporary login.',
                expire => '19971013191724',
                hits => '0',
                name => 'Anon-6',
                owner => User { ... }
                reflected => 3,
                rel => ObjStore::Set [
                  Node { ... }
                ],
                views => ObjStore::HV {
                  1 => User::View { ... }
                  2 => User::View { ... }
                },
              },
              joshua => User {
                ctime => '19970814113317',
                daily_hits => ObjStore::HV {
                  19970814 => 13,
                },
                desc => '',
                dreamer => 1,
                expire => '19971013182157',
                hits => 13,
                name => 'joshua',
                owner => User { ... }
                passwd => 'zzReR55rX6.JA',
                proposals => ObjStore::Set [
                  User::Proposal {
                    about => Node { ... }
                    ctime => '19970814195243',
                    from => User { ... }
                    to => User { ... }
                  },
                ],
                reflected => 3,
                rel => ObjStore::Set [
                  Node { ... }
                ],
                url => '',
                views => ObjStore::HV {
                  1 => User::View { ... }
                  2 => User::View { ... }
                },
              },
            },
            name => 'Users',
            owner => Node { ... }
            reflected => 2,
            rel => ObjStore::Set [
              Node { ... }
              User { ... }
              User { ... }
              User { ... }
              User { ... }
            ],
          },
          Node { ... }
        ],
      },
      Node { ... }
      Node { ... }
    ],
  },


=head1 WHY IS PERL A BETTER FIT FOR DATABASES THAN SQL, C++, OR JAVA?

When you write a structure declaration in C++ or Java you are
assigning both field-names, field-types, and field-order.

  struct CXX {
	char *name;
	char *title;
	double size;
  };

Programs almost always require a recompile to change any of these
attributes.  This is fine for small to medium size applications but is
not suitable for large databases.  It is too inflexible.  An SQL-type
language is needed.

When you create a table in SQL you are assigning only field-names and
field-types.

  create table CXX
  (name varchar(80),
   title varchar(80),
   size double)

This is a more flexible data declaration, but SQL gives you far less
expressive power than C++ or Java.  Applications end up being written
in C++ or Java while their data is stored in SQL.  Managing the
syncronization between the two languages creates a lot of extra
complexity.  So much so that there are many software companies that
exist solely to help address this headache.

perl is better because it spans all the requirements in a single
language.  For example, this is similar to an SQL table:

  my $h1 = { name => undef, title => undef, size => undef };

Only the field-names are specified.

To address the other side of the spectrum, Malcolm Beattie is working
on a perl compiler which is currently in beta-test.  Here is his brief
description of a new hybrid hash-array that is supported:

	An array ref $a can be dereferenced as if it were a hash
ref.  $a->{foo} looks up the key "foo" in %{$a->[0]}. The value is the
index in the true underlying array @$a. As an addition, if the array
ref is in a lexical variable tagged with a classname ("my CXX $obj" to
match your example above) then constant key dereferences of the form
$obj->{foo} are mapped to $obj->[123] at compile time by looking up
the index in %CXX::FIELDS.

For example:

  my $schema_hashref = { 'field1' => 1, 'field2' => 2 };
  my $arr = [$schema_hashref, 'fwaz', 'snorf'];
  print "$arr->{field1} : $arr->{field2}\n";      # "fwaz : snorf"

I haven't done benchmarks yet, but considering the implementation,
compiled fake hashes should make perl very competitive with Java /
ObjectStore database applications in terms of raw performance.

=head2 Summary (long)

=over 4

=item * SQL

All perl databases use the same flexible schema that can be examined
and updated with generic tools.  This is the key advantage of SQL, now
available in perl.

Perl / ObjectStore is definitely faster than SQL too. Not to mention
that perl is a general purpose programming language and SQL is at best
a 'query language'.

=item * C++

Special purpose data types can be coded in C++ and dynamically linked
into perl.  Since C++ will always be faster than Java, this gives perl
an edge in the long run.  perl is to C/C++ as C/C++ is to assembly language.

=item * JAVA

Java has the buzz, but!

=over 4

=item *

Just like C++, the lack of a universal generic schema limits use to a
single application at a time.  Without some sort of C<tie> mechanism,
I don't see how this can be remedied.

=item *

All Java databases must serialize data to store it.  Until Java
supports persistent allocation directly, database operations will
always be slower than C++.

=item *

Perl will soon integrate with Java enough to use SwingSet - AWT.

=item *

I'd like to see some comparisions of code length when solving the same
problems in Java and in perl.  I have a strong suspicion that it is
easier to do data processing in perl.

=back

=back

=head2 ETA

=over 4

=item * 0-3 MONTHS

Perl compiler; kernel threads; fake hashes

=item * 3-6 MONTHS

Dynamically loaded application schemas;
proper tied arrays; debugged tie interface;
perl-Java integration

=back

=head2 Summary (short)

Perl can store data

=over 4

=item *

optimized for flexibility or for speed

=item * 

in transient memory or persistent memory

=back

without violating the principle of encapsulation or obstructing
general ease of use.

=head1 ADVANCED FEATURES

=head2 Bless

The ObjStore module installs its own version of C<bless> which assures
that blessings are persistent.  For example:

    package MyObject;
    use ObjStore;
    @ISA = qw(ObjStore::HV);
    sub new {
        my ($class, $store) = @_;
        my $o = $class->SUPER::new($store, $class);
        $o->{attribute} = 5;
        $o;
    }

    package main;
    my $o = new MyObject($db);

If you store each class in a separate C<.pm> file in your @INC path
(see C<require>), then the classes will be autoloaded as you traverse
your data.

=head2 Class Autoloading

ObjStore tries to C<require> each class as you access persistent
instances the first time.  This means that you can write generic data
processing programs that automatically load the appropriate libraries
to manipulate data as the data is accessed.

To disable the class autoloading behavior:

  ObjStore::disable_class_auto_loading();

This mechanism is orthogonal to the C<AUTOLOAD> mechanism for
autoloading functions.

=head2 Transactions Part Two

=over 4

=item * EVAL

Transactions are always executed within an implicit C<eval>.  If you
do not want to abort your program when an ObjectStore exception
occurs, you should indicate that you want to check errors yourself:

  ObjStore::rethrow_exceptions(0);

After a transaction, you will need to check the value of C<$@> to see
if anything went wrong and determine how to proceed.

  try_update {
     ...
  };
  die if $@;    # check for errors!

=item * DEADLOCK

Transactions are automatically retried in the case of a deadlock.  If
you need to handle deadlocks specially, you can use
ObjStore::set_max_retries(0) and write the logic (or illogic)
yourself.

=back

=head2 Stargate

The stargate determines which collection representations are used to
store implicitly created hashes and arrays.  It is called recursively
on data structures in order to copy them into persistent memory.  If
you replace the default stargate with your own, make sure to dismember
the transient structures as they are processed to insure that circular
structures will be collected in transient memory.

  ObjStore::set_stargate(sub {
    my ($seg, $sv) = @_;
    my $type = reftype $sv;
    my $class = ref $sv;
    if ($type eq 'HASH') {
	my $hv = new ObjStore::HV($seg, ...);
	while (my($hk,$v) = each %$sv) { $hv->STORE($hk, $v); }
	%$sv = ();
	if ($class ne 'HASH') { ObjStore::bless $hv, $class; }
	$hv
    } elsif ($type eq 'ARRAY') {
        ...
    } else {
	croak("Stargate: Don't know how to translate $sv");
    }
  };

=head1 TECHNICAL IMPLEMENTATION

You don't have to understand anything about the technical
implementation.  Just know that:

=over 4

=item *

ObjectStore is outrageously powerful, sophisticated, even
over-engineered.

=item *

The perl interface is optimized for simplicity and easy of use.  I<(If it's
not fun, why bother?)>

=back

The performance of raw ObjectStore is so good that even with a gunky
perl layer, benchmarks will show that relational databases can be
safely left on the bookshelf where they belong.

=head2 Differences Between The Perl And C++ APIs

Most stuff should be exactly the same.  However,

=over 4

=item *

Some static methods sit directly under C<ObjStore::>.

=item *

Transactions are simplified.

=back

=head2 Data Representation

Memory usage is much more important in a database than in transient
memory.  When databases can be as large or larger than ten million
megabytes, a few percent difference in compactness can mean a lot.
Therefore, I am always thinking about ways of conserving persistent
memory.

  enum ossvtype {
    ossv_undef=1,
    ossv_iv=2,    // integer
    ossv_nv=3,    // double
    ossv_pv=4,    // string
    ossv_obj=5	  // ref counted objects (containers or complex objects)
  };

  struct OSSV {               // persistent scalar
    void *vptr;
    os_unsigned_int16 _refs;  //unused
    os_int16 _type;
  };

  struct hkey {               // hash key
    char *pv;
    os_unsigned_int32 len;
  };

  struct hent {               // hash element
    hkey hk;
    OSSV hv;
  };

  struct OSPV_iv {            // IV storage
    os_int32 iv;
  };

  struct OSPV_nv {            // NV storage
    double nv;
  };

There are number of weaknesses in the current schema:

=over 4

=item * OSSV

The refcnt is no longer used and the type of an OSSV could be inferred
instead of stored (save 4 bytes per OSSV).  The same I32 can be used
for an integer value or string length (save an allocation per I32).

=item * HASH KEYS

Hash keys store their length but not their hash.  Actually, hash keys
probably shouldn't even cache their hashed value, just a straight
char* to minimize memory usage (save 4 bytes & an allocation).

=item * STRINGS

Strings do not store their length so you can't store strings with
embedded NULLs.

=item * NO WEAK REFERENCES

=back

Changes will be made as soon as I finish the database evolver.

=head2 Go Extension Crazy

C<ObjStore::UNIVERSAL> is the base class for all persistent objects.
You cannot directly access persistent scalars from perl. They are
always immediately copied into transient scalars.  So the
C<ObjStore::UNIVERSAL> base class is only for objects (or
collections).

C<ObjStore::UNIVERSAL::Container> is the base class for all
containers.

C<ObjStore::Set> is the base class for sets.

C<ObjStore::HV> is the base class for tied hashes.

C<ObjStore::AV> is the base class for tied arrays.

C<ObjStore::Cursor> is the base class for cursors.

C<ObjStore::File> will be the base class for large binary data.

When an ObjectStore exception occurs, C<$ObjStore::EXCEPTION> is
called with an explaination.  You can replace the default handler with
your own function.

Each subclass of C<ObjStore::UNIVERSAL> has a C<%REP> hash.
Persistent object implementations add their creation functions to the
hash.  Each packages' C<new> method decides on the best
representation, calls the creation function, and returns the
persistent object.

You can add your own C++ representations for each of Set, AV, and HV.
If you want to know the specifics, look at the code for the provided
built-in representations (C<GENERIC.*>).

You can add new families of objects that inherit from
C<ObjStore::UNIVERSAL>.  Suppose you want highly optimized, persistent
bit vectors?  Or matrics?  These would not be difficult to add.
Especially once Object Design figures out how to support multiple
application schemas within the same executable.  They claim that this
tonal facility will be available in the next release.

=head2 ossv_bridge typemap

The following explaination may be helpful to developers trying to
understand the ObjStore typemap.  If you don't know what a typemap is,
just skip to the next section.

The struct C<ossv_bridge> is used to bridge between perl and C++
objects.  It contains transient cursors and transient pointers to
persistent data.  Immediately after a transaction finishes,
C<invalidate> is invoked on all outstanding bridges.  This is
necessary in order to update the reference counts properly.  This was
also the most difficult part to get right.  But hey, how many
databases do reference counting?

=head1 DIRECTION

=over 4

=item * MORE BUILT-IN DATA TYPES

Text objects implemented using osmmtype and subclassed from
IO::Handle.  Support for one of Object Design's Text Object Managers.
Support for bit vectors and matrics.

=item * MORE APIS

Support for notification, database access control, and any other
interesting ObjectStore APIs.

=back

=head1 EXPORTS

C<bless>, C<try_read>, C<try_update>, C<try_abort_only> by default.
Most other static methods can also be exported.

=head1 BUGS

=over 4

=item * NESTED TRANSACTIONS

Disabled until the transaction support is cleaned up.

=item * CURSED OBJECTS

The strings used to record the blessed nature of persistent objects
are allocated in a private hash in the default segment of a database
(See C<'ospeek -all'>).  If you accidentally mess up or change any of
these strings, your objects will be cursed.  You will need to re-bless
each to fix the broken pointers.  A database copy script is in the
works.

=back

=head1 AUTHOR

Copyright (c) 1997 Joshua Nathaniel Pritikin.  All rights reserved.

This package is free software; you can redistribute it and/or modify
it under the same terms as perl itself.  perl / ObjectStore is available
via any CPAN mirror site.  See
http://www.perl.com/CPAN/modules/by-module/ObjStore

Portions of the collection code snapped from I<splash>, Jim Morris's
delightful C++ library ftp://ftp.wolfman.com/users/morris/public/splash .

Also, a poignant thanks to all the wonderful teachers with which I've
had the opportunity of studying.

=head1 SEE ALSO

Examples in the t/ directory, perl5, ObjectStore, I<and happily not
SQL!>

=cut
